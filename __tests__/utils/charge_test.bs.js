// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$WoocommercePayments = require("../../client/utils/charge/util.bs.js");
var Types$WoocommercePayments = require("../../client/data/types.bs.js");

var paidCharge = Types$WoocommercePayments.Charge.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "succeeded", undefined);

var failedCharge = Types$WoocommercePayments.Charge.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, undefined, undefined, undefined, undefined, undefined, undefined, Caml_option.some(Types$WoocommercePayments.Outcome.make("issuer_declined", undefined)), false, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "failed", undefined);

var blockedCharge = Types$WoocommercePayments.Charge.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, undefined, undefined, undefined, undefined, undefined, undefined, Caml_option.some(Types$WoocommercePayments.Outcome.make("blocked", undefined)), false, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "failed", undefined);

var authorizedCharge = Types$WoocommercePayments.Charge.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "succeeded", undefined);

var fullyRefundedCharge = Types$WoocommercePayments.Charge.make(undefined, undefined, 1500, 1500, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true, undefined, undefined, undefined);

var partiallyRefundedCharge = Types$WoocommercePayments.Charge.make(undefined, undefined, 1500, 1200, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, undefined, undefined, undefined);

function getDisputedChargeWithStatus(status) {
  return Types$WoocommercePayments.Charge.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, Caml_option.some(Types$WoocommercePayments.Dispute.make(status, undefined)), true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

Jest.describe("Charge utilities (ReasonML)", (function (param) {
        Jest.describe("isCharge methods", (function (param) {
                Jest.test("should identify a captured successful charge as successful", (function (param) {
                        return Jest.Expect.toEqual(true, Jest.Expect.expect(Util$WoocommercePayments.isChargeSuccessful(paidCharge)));
                      }));
                Jest.test("should identify a not captured successful charge as successful", (function (param) {
                        return Jest.Expect.toEqual(true, Jest.Expect.expect(Util$WoocommercePayments.isChargeSuccessful(authorizedCharge)));
                      }));
                Jest.test("should not identify a failed charge as successful", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargeSuccessful(failedCharge)));
                      }));
                Jest.test("should not identify a blocked charge as successful", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargeSuccessful(blockedCharge)));
                      }));
                Jest.test("should identify a failed charge as failed", (function (param) {
                        return Jest.Expect.toEqual(true, Jest.Expect.expect(Util$WoocommercePayments.isChargeFailed(failedCharge)));
                      }));
                Jest.test("should identify a blocked charge as blocked", (function (param) {
                        return Jest.Expect.toEqual(true, Jest.Expect.expect(Util$WoocommercePayments.isChargeBlocked(blockedCharge)));
                      }));
                Jest.test("should not identify a successful charge as failed", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargeFailed(paidCharge)));
                      }));
                Jest.test("should not identify a successful charge as failed", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargeBlocked(paidCharge)));
                      }));
                Jest.test("should identify a fully refunded charge as fully refunded", (function (param) {
                        return Jest.Expect.toEqual(true, Jest.Expect.expect(Util$WoocommercePayments.isChargeFullyRefunded(fullyRefundedCharge)));
                      }));
                Jest.test("should not identify a partially refunded charge as fully refunded", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargeFullyRefunded(partiallyRefundedCharge)));
                      }));
                Jest.test("should not identify a successful charge as fully refunded", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargeFullyRefunded(paidCharge)));
                      }));
                Jest.test("should identify a partially refunded charge as partially refunded", (function (param) {
                        return Jest.Expect.toEqual(true, Jest.Expect.expect(Util$WoocommercePayments.isChargePartiallyRefunded(partiallyRefundedCharge)));
                      }));
                Jest.test("should not identify a fully refunded charge as partially refunded", (function (param) {
                        return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargePartiallyRefunded(fullyRefundedCharge)));
                      }));
                return Jest.test("should not identify a successful charge as partially refunded", (function (param) {
                              return Jest.Expect.toEqual(false, Jest.Expect.expect(Util$WoocommercePayments.isChargePartiallyRefunded(paidCharge)));
                            }));
              }));
        return Jest.describe("getChargeStatus", (function (param) {
                      var chargeStatuses_0 = [
                        /* Paid */9,
                        paidCharge
                      ];
                      var chargeStatuses_1 = {
                        hd: [
                          /* Authorized */10,
                          authorizedCharge
                        ],
                        tl: {
                          hd: [
                            /* Failed */0,
                            failedCharge
                          ],
                          tl: {
                            hd: [
                              /* FullyRefunded */8,
                              fullyRefundedCharge
                            ],
                            tl: {
                              hd: [
                                /* PartiallyRefunded */7,
                                partiallyRefundedCharge
                              ],
                              tl: /* [] */0
                            }
                          }
                        }
                      };
                      var chargeStatuses = {
                        hd: chargeStatuses_0,
                        tl: chargeStatuses_1
                      };
                      Jest.testAll("returns status for charge", chargeStatuses, (function (param) {
                              return Jest.Expect.toEqual({
                                          TAG: /* Ok */0,
                                          _0: param[0]
                                        }, Jest.Expect.expect(Util$WoocommercePayments.getChargeStatus(param[1])));
                            }));
                      var disputeStatuses = {
                        hd: [
                          "needs_response",
                          /* DisputeNeedsResponse */2
                        ],
                        tl: {
                          hd: [
                            "under_review",
                            /* DisputeUnderReview */3
                          ],
                          tl: {
                            hd: [
                              "won",
                              /* DisputeWon */4
                            ],
                            tl: {
                              hd: [
                                "lost",
                                /* DisputeLost */5
                              ],
                              tl: {
                                hd: [
                                  "warning_needs_response",
                                  /* DisputeNeedsResponse */2
                                ],
                                tl: {
                                  hd: [
                                    "warning_under_review",
                                    /* DisputeUnderReview */3
                                  ],
                                  tl: {
                                    hd: [
                                      "warning_closed",
                                      /* Disputed */6
                                    ],
                                    tl: /* [] */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      };
                      Jest.testAll("returns disputed status", disputeStatuses, (function (param) {
                              return Jest.Expect.toEqual({
                                          TAG: /* Ok */0,
                                          _0: param[1]
                                        }, Jest.Expect.expect(Util$WoocommercePayments.getChargeStatus(getDisputedChargeWithStatus(param[0]))));
                            }));
                      return Jest.testAll("disputed statuses take precedence over refunds", disputeStatuses, (function (param) {
                                    var charge = Types$WoocommercePayments.Charge.make(undefined, undefined, 1500, 1500, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, Caml_option.some(Types$WoocommercePayments.Dispute.make(param[0], undefined)), true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true, undefined, undefined, undefined);
                                    return Jest.Expect.toEqual({
                                                TAG: /* Ok */0,
                                                _0: param[1]
                                              }, Jest.Expect.expect(Util$WoocommercePayments.getChargeStatus(charge)));
                                  }));
                    }));
      }));

exports.paidCharge = paidCharge;
exports.failedCharge = failedCharge;
exports.blockedCharge = blockedCharge;
exports.authorizedCharge = authorizedCharge;
exports.fullyRefundedCharge = fullyRefundedCharge;
exports.partiallyRefundedCharge = partiallyRefundedCharge;
exports.getDisputedChargeWithStatus = getDisputedChargeWithStatus;
/* paidCharge Not a pure module */
